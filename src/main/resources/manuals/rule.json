{
  "expr": {
    "If control reaches here, then _genContext_ is the running execution context again.": "(= genContext @EXECUTION_STACK[0])",
    "The execution context stack has at least two elements.": "(< 1 @EXECUTION_STACK.length)",
    "The execution context stack is empty.": "(= @EXECUTION_STACK.length 0)",
    "The execution context stack is not empty.": "(! (= @EXECUTION_STACK.length 0))",
    "This is an attempt to change the value of an immutable binding.": "true",
    "When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.": "(&& (= prevContext @EXECUTION_STACK[0]) (! (= asyncContext @EXECUTION_STACK[0])))",
    "When we return here, _asyncContext_ has already been removed from the execution context stack and _runningContext_ is the currently running execution context.": "(&& (= runningContext @EXECUTION_STACK[0]) (! (= asyncContext @EXECUTION_STACK[0])))",
    "When we return here, _genContext_ has already been removed from the execution context stack and _callerContext_ is the currently running execution context.": "(&& (= callerContext @EXECUTION_STACK[0]) (! (= genContext @EXECUTION_STACK[0])))",
    "When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context.": "(= methodContext @EXECUTION_STACK[0])",
    "_F_ has a [[Promise]] internal slot whose value is an Object.": "(&& (! (= F.Promise absent)) (? F.Promise: Record[Object]))",
    "_F_ is an extensible object that does not have a *\"length\"* own property.": "(&& F.Extensible (= F.__MAP__.length absent))",
    "_F_ is an extensible object that does not have a *\"name\"* own property.": "(&& F.Extensible (= F.__MAP__.name absent))",
    "_F_ is an extensible object that does not have a *\"prototype\"* own property.": "(&& F.Extensible (= F.__MAP__.prototype absent))",
    "_O_ is an Object that has a [[SyncIteratorRecord]] internal slot.": "(&& (? O: Record[Object]) (! (= O.SyncIteratorRecord absent)))",
    "_O_ is an ordinary, extensible object with no non-configurable properties.": "(&& (? O: Record[OrdinaryObject]) O.Extensible)",
    "_Receiver_ does not currently have a property _P_.": "(= Receiver.__MAP__[P] absent)",
    "_base_ is finite and is neither *+0*<sub>ùîΩ</sub> nor *-0*<sub>ùîΩ</sub>.": "(! (|| (= base 0.0f) (= base -0.0f)))",
    "_calleeContext_ is now the running execution context.": "(= calleeContext @EXECUTION_STACK[0])",
    "_envRec_ does not already have a binding for _N_.": "(= envRec.__MAP__[N] absent)",
    "_envRec_ must have an uninitialized binding for _N_.": "(= envRec.__MAP__[N].initialized false)",
    "_exponent_ is finite and is neither *+0*<sub>ùîΩ</sub> nor *-0*<sub>ùîΩ</sub>.": "(! (|| (= exponent 0.0f) (= exponent -0.0f)))",
    "_genContext_ is the execution context of a generator.": "(? genContext: Record[ExecutionContext])",
    "_realm_.[[Intrinsics]].[[%ThrowTypeError%]] exists and has been initialized.": "(! (= realm.Intrinsics[\"%ThrowTypeError%\"] absent))",
    "_x_ and _y_ are both finite.": "(&& (! (|| (= x +INF) (= x -INF))) (! (|| (= y +INF) (= y -INF))))"
  },
  "inst": {
    "<emu-not-ref>Record</emu-not-ref> that the binding for _N_ in _envRec_ has been initialized.": "envRec.__MAP__[N].initialized = true",
    "Append the pair (a two element List) consisting of _nextKey_ and _desc_ to the end of _descriptors_.": "push descriptors < (list [nextKey, desc])",
    "Append to _internalSlotsList_ the elements of _additionalInternalSlotsList_.": "internalSlotsList = (list-concat internalSlotsList additionalInternalSlotsList)",
    "Change its bound value to _V_.": "envRec.__MAP__[N].BoundValue = V",
    "Create a mutable binding in _envRec_ for _N_ and record that it is uninitialized. If _D_ is *true*, record that the newly created binding may be deleted by a subsequent DeleteBinding call.": "{ envRec.__MAP__[N] = (record [MutableBinding] { \"initialized\" : false })  if (= D true) envRec.__MAP__[N].maybeDeleted = true }",
    "Create an immutable binding in _envRec_ for _N_ and record that it is uninitialized. If _S_ is *true*, record that the newly created binding is a strict binding.": "envRec.__MAP__[N] = (record [ImmutableBinding] { \"initialized\" : false, \"strict\" : S })",
    "Create an own accessor property named _P_ of object _O_ whose [[Get]], [[Set]], [[Enumerable]], and [[Configurable]] attributes are set to the value of the corresponding field in _Desc_ if _Desc_ has that field, or to the attribute's <emu-xref href=\"#table-object-property-attributes\">default value</emu-xref> otherwise.": "{ let ap = (record [PropertyDescriptor] { }) if (= Desc.Get absent) ap.Get = undefined else ap.Get = Desc.Get if (= Desc.Set absent) ap.Set = undefined else ap.Set = Desc.Set if (= Desc.Enumerable absent) ap.Enumerable = false else ap.Enumerable = Desc.Enumerable if (= Desc.Configurable absent) ap.Configurable = false else ap.Configurable = Desc.Configurable O.__MAP__[P] = ap }",
    "Create an own data property named _P_ of object _O_ whose [[Value]], [[Writable]], [[Enumerable]], and [[Configurable]] attributes are set to the value of the corresponding field in _Desc_ if _Desc_ has that field, or to the attribute's <emu-xref href=\"#table-object-property-attributes\">default value</emu-xref> otherwise.": "{ let dp = (record [PropertyDescriptor] { }) if (= Desc.Value absent) dp.Value = undefined else dp.Value = Desc.Value if (= Desc.Writable absent) dp.Writable = false else dp.Writable = Desc.Writable if (= Desc.Enumerable absent) dp.Enumerable = false else dp.Enumerable = Desc.Enumerable if (= Desc.Configurable absent) dp.Configurable = false else dp.Configurable = Desc.Configurable O.__MAP__[P] = dp }",
    "Create any host-defined global object properties on _globalObj_.": "nop",
    "For each field of _Desc_, set the corresponding attribute of the property named _P_ of object _O_ to the value of the field.": "{ let fields = (keys Desc) let idx = 0 while (< idx fields.length) { let f = fields[idx] O.__MAP__[P][f] = Desc[f] idx = (+ idx 1) } }",
    "For each property of the Global Object specified in clause <emu-xref href=\"#sec-global-object\"></emu-xref>, do\n  1. Let _name_ be the String value of the property name.\n  1. Let _desc_ be the fully populated data Property Descriptor for the property, containing the specified attributes for the property. For properties listed in <emu-xref href=\"#sec-function-properties-of-the-global-object\"></emu-xref>, <emu-xref href=\"#sec-constructor-properties-of-the-global-object\"></emu-xref>, or <emu-xref href=\"#sec-other-properties-of-the-global-object\"></emu-xref> the value of the [[Value]] attribute is the corresponding intrinsic object from _realmRec_.\n  1. Perform ? DefinePropertyOrThrow(_global_, _name_, _desc_).": "{ let keys = (keys @GLOBAL.__MAP__) let idx = 0 while (< idx keys.length) { let name = keys[idx] global.__MAP__[name] = @GLOBAL.__MAP__[name] idx = (+ idx 1) } global.__MAP__.globalThis = (record [PropertyDescriptor] { \"Value\" : global, \"Writable\" : true, \"Enumerable\" : false, \"Configurable\" : true }) }",
    "If the host is a web browser, then\n  1. Perform ? HostEnsureCanAddPrivateElement(_O_).": "nop",
    "If _Desc_ does not have any fields, return *true*.": "{ let descKeys = (keys Desc) if (= descKeys.length 0) return true }",
    "If _O_ does not have an own property with key _P_, return *undefined*.": "if (= O.__MAP__[P] absent) return undefined",
    "If _callerContext_ is not already suspended, suspend _callerContext_.": "nop",
    "If _child_ is an instance of _symbol_, return *true*.": "if (instanceof child symbol) return true",
    "If _genContext_ does not have a Generator component, return ~non-generator~.": "if (= genContext.Generator absent) return ~non-generator~",
    "If _runningContext_ is not already suspended, suspend _runningContext_.": "nop",
    "If _x_ and _y_ are both *true* or both *false*, return *true*; otherwise, return *false*.": "if (|| (&& (= x true) (= y true)) (&& (= x false) (= y false))) return true else return false",
    "If _x_ and _y_ have the same length and the same code units in the same positions, return *true*; otherwise, return *false*.": "if (= x y) return true else return false",
    "If all Job Queues are empty, the result is implementation-defined.": "if (= @JOB_QUEUE.length 0) return errors",
    "If no such execution context exists, return *null*. Otherwise, return _ec_'s ScriptOrModule.": "if (= ec absent) return null else return ec.ScriptOrModule",
    "If only one argument was passed, return _to_.": "if (= ArgumentsList.length 0) return to",
    "If the binding for _N_ in _envRec_ is an uninitialized binding, throw a *ReferenceError* exception.": "if (! envRec.__MAP__[N].initialized) { call __errObj__ = clo<\"__NEW_ERROR_OBJ__\">(\"%ReferenceError.prototype%\") call __comp__ = clo<\"ThrowCompletion\">(__errObj__) return __comp__ }",
    "If the execution context stack is empty, return *null*.": "if (= @EXECUTION_STACK.length 0) return null",
    "If the host requires that the `this` binding in _realm_'s global scope return an object other than the global object, let _thisValue_ be such an object created in a host-defined manner. Otherwise, let _thisValue_ be *undefined*, indicating that _realm_'s global `this` binding should be the global object.": "let thisValue = undefined",
    "If the host requires use of an exotic object to serve as _realm_'s global object, let _global_ be such an object created in a host-defined manner. Otherwise, let _global_ be *undefined*, indicating that an ordinary object should be created as the global object.": "let global = undefined",
    "Insert _d_ as the first element of _functionsToInitialize_.": "push d > functionsToInitialize",
    "Insert _fn_ as the first element of _functionNames_.": "push fn > functionNames",
    "Let _X_ be _O_'s own property whose key is _P_.": "let X = O.__MAP__[P]",
    "Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].": "let args = ArgumentsList",
    "Let _asyncContext_ be a copy of _runningContext_.": "let asyncContext = (copy runningContext)",
    "Let _contained_ be the result of _child_ Contains _symbol_.": "{ sdo-call result = child->Contains(symbol) let contained = result }",
    "Let _ec_ be the topmost execution context on the execution context stack whose ScriptOrModule component is not *null*.": "{ let ec = absent let idx = 0 while (&& (< idx @EXECUTION_STACK.length) (= ec absent)) { if (! (= @EXECUTION_STACK[idx].ScriptOrModule null) ) ec = @EXECUTION_STACK[idx] idx = (+ idx 1) } }",
    "Let _func_ be a new built-in function object that, when called, performs the action described by _behaviour_ using the provided arguments as the values of the corresponding parameters specified by _behaviour_. The new function object has internal slots whose names are the elements of _internalSlotsList_, and an [[InitialName]] internal slot.": "{ let func = (record [BuiltinFunctionObject] { \"__MAP__\" : (map), \"PrivateElements\" : (list []) }) func.Code = behaviour }",
    "Let _instantiatedVarNames_ be a copy of the List _parameterBindings_.": "let instantiatedVarNames = (copy parameterBindings)",
    "Let _internalSlotsList_ be a List containing the names of all the internal slots that <emu-xref href=\"#sec-built-in-function-objects\"></emu-xref> requires for the built-in function object that is about to be created.": "let internalSlotsList = (list [\"Prototype\", \"Extensible\", \"Realm\", \"InitialName\"])",
    "Let _newLenDesc_ be a copy of _Desc_.": "let newLenDesc = (copy Desc)",
    "Let _nextPending_ be the PendingJob record at the front of _nextQueue_. Remove that record from _nextQueue_.": "let nextPending = (pop < @JOB_QUEUE)",
    "Let _nextQueue_ be a non-empty Job Queue chosen in an implementation-defined manner.": "let nextQueue = @JOB_QUEUE",
    "Let _obj_ be a newly created object with an internal slot for each name in _internalSlotsList_.": "{ let obj = (record [Object] { \"__MAP__\" : (map), \"PrivateElements\" : (list []) }) let idx = 0 while (< idx internalSlotsList.length) { obj[internalSlotsList[idx]] = undefined idx = (+ idx 1) } }",
    "Let _opText_ be the sequence of Unicode code points associated with _assignmentOpText_ in the following table:\n  <figure>\n    <!-- emu-format ignore -->\n    <table class=\"lightweight-table\">\n    <tbody><tr><th> _assignmentOpText_ </th><th> _opText_       </th></tr>\n    <tr><td> `**=`              </td><td> `**`           </td></tr>\n    <tr><td> `*=`               </td><td> `*`            </td></tr>\n    <tr><td> `/=`               </td><td> `/`            </td></tr>\n    <tr><td> `%=`               </td><td> `%`            </td></tr>\n    <tr><td> `+=`               </td><td> `+`            </td></tr>\n    <tr><td> `-=`               </td><td> `-`            </td></tr>\n    <tr><td> `<<=`        </td><td> `<<`     </td></tr>\n    <tr><td> `>>=`        </td><td> `>>`     </td></tr>\n    <tr><td> `>>>=`    </td><td> `>>>` </td></tr>\n    <tr><td> `&=`           </td><td> `&`        </td></tr>\n    <tr><td> `^=`               </td><td> `^`            </td></tr>\n    <tr><td> `|=`               </td><td> `|`            </td></tr>\n    </tbody></table>\n  </figure>": "{ if (= assignmentOpText \"**=\") let opText = \"**\" if (= assignmentOpText \"*=\") let opText = \"*\" if (= assignmentOpText \"/=\") let opText = \"/\" if (= assignmentOpText \"%=\") let opText = \"%\" if (= assignmentOpText \"+=\") let opText = \"+\" if (= assignmentOpText \"-=\") let opText = \"-\" if (= assignmentOpText \"<<=\") let opText = \"<<\" if (= assignmentOpText \">>=\") let opText = \">>\" if (= assignmentOpText \">>>=\") let opText = \">>>\" if (= assignmentOpText \"&=\") let opText = \"&\" if (= assignmentOpText \"^=\") let opText = \"^\" if (= assignmentOpText \"|=\") let opText = \"|\" }",
    "Let _operation_ be the abstract operation associated with _opText_ and Type(_lnum_) in the following table:\n  <figure>\n    <!-- emu-format ignore -->\n    <table class=\"lightweight-table\">\n    <tbody><tr><th> _opText_       </th><th> Type(_lnum_) </th><th> _operation_                </th></tr>\n    <tr><td> `**`           </td><td> Number       </td><td> Number::exponentiate       </td></tr>\n    <tr><td> `*`            </td><td> Number       </td><td> Number::multiply           </td></tr>\n    <tr><td> `*`            </td><td> BigInt       </td><td> BigInt::multiply           </td></tr>\n    <tr><td> `/`            </td><td> Number       </td><td> Number::divide             </td></tr>\n    <tr><td> `%`            </td><td> Number       </td><td> Number::remainder          </td></tr>\n    <tr><td> `+`            </td><td> Number       </td><td> Number::add                </td></tr>\n    <tr><td> `+`            </td><td> BigInt       </td><td> BigInt::add                </td></tr>\n    <tr><td> `-`            </td><td> Number       </td><td> Number::subtract           </td></tr>\n    <tr><td> `-`            </td><td> BigInt       </td><td> BigInt::subtract           </td></tr>\n    <tr><td> `<<`     </td><td> Number       </td><td> Number::leftShift          </td></tr>\n    <tr><td> `<<`     </td><td> BigInt       </td><td> BigInt::leftShift          </td></tr>\n    <tr><td> `>>`     </td><td> Number       </td><td> Number::signedRightShift   </td></tr>\n    <tr><td> `>>`     </td><td> BigInt       </td><td> BigInt::signedRightShift   </td></tr>\n    <tr><td> `>>>` </td><td> Number       </td><td> Number::unsignedRightShift </td></tr>\n    <tr><td> `&`        </td><td> Number       </td><td> Number::bitwiseAND         </td></tr>\n    <tr><td> `&`        </td><td> BigInt       </td><td> BigInt::bitwiseAND         </td></tr>\n    <tr><td> `^`            </td><td> Number       </td><td> Number::bitwiseXOR         </td></tr>\n    <tr><td> `^`            </td><td> BigInt       </td><td> BigInt::bitwiseXOR         </td></tr>\n    <tr><td> `|`            </td><td> Number       </td><td> Number::bitwiseOR          </td></tr>\n    <tr><td> `|`            </td><td> BigInt       </td><td> BigInt::bitwiseOR          </td></tr>\n    </tbody></table>\n  </figure>": "if (? lnum: Number) { if (= opText \"**\") let operation = clo<\"Number::exponentiate\"> if (= opText \"*\") let operation = clo<\"Number::multiply\"> if (= opText \"/\") let operation = clo<\"Number::divide\"> if (= opText \"%\") let operation = clo<\"Number::remainder\"> if (= opText \"+\") let operation = clo<\"Number::add\"> if (= opText \"-\") let operation = clo<\"Number::subtract\"> if (= opText \"<<\") let operation = clo<\"Number::leftShift\"> if (= opText \">>\") let operation = clo<\"Number::signedRightShift\"> if (= opText \">>>\") let operation = clo<\"Number::unsignedRightShift\"> if (= opText \"&\") let operation = clo<\"Number::bitwiseAND\"> if (= opText \"^\") let operation = clo<\"Number::bitwiseXOR\"> if (= opText \"|\") let operation = clo<\"Number::bitwiseOR\"> } else if (? lnum: BigInt) { if (= opText \"*\") let operation = clo<\"BigInt::multiply\"> if (= opText \"+\") let operation = clo<\"BigInt::add\"> if (= opText \"-\") let operation = clo<\"BigInt::subtract\"> if (= opText \"<<\") let operation = clo<\"BigInt::leftShift\"> if (= opText \">>\") let operation = clo<\"BigInt::signedRightShift\"> if (= opText \"&\") let operation = clo<\"BigInt::bitwiseAND\"> if (= opText \"^\") let operation = clo<\"BigInt::bitwiseXOR\"> if (= opText \"|\") let operation = clo<\"BigInt::bitwiseOR\"> } else { }",
    "Let _privateName_ be the Private Name in _names_ whose [[Description]] is _privateIdentifier_.": "{ let idx = 0 while (< idx names.length) { let elem = names[idx] if (= elem.Description privateIdentifier) let privateName = elem idx = (+ idx 1) } }",
    "Let _realmRec_ be a new Realm Record.": "let realmRec = @REALM",
    "Let _result_ be the Completion Record that is <emu-meta effects=\"user-code\">the result of evaluating</emu-meta> _F_ in a manner that conforms to the specification of _F_. If _thisArgument_ is ~uninitialized~, the *this* value is uninitialized; otherwise, _thisArgument_ provides the *this* value. _argumentsList_ provides the named parameters. _newTarget_ provides the NewTarget value.": "if (= thisArgument ~uninitialized~) call result = F.Code(undefined, argumentsList, newTarget) else call result = F.Code(thisArgument, argumentsList, undefined)",
    "Let _sourceText_ be the source code of a script.": "let sourceText = @SOURCE_TEXT",
    "Perform any necessary implementation-defined initialization of _calleeContext_.": "nop",
    "Remove the own property with name _P_ from _O_.": "delete O.__MAP__[P]",
    "Replace the property named _P_ of object _O_ with a data property whose [[Configurable]] and [[Enumerable]] attributes are set to _configurable_ and _enumerable_, respectively, and whose [[Value]] and [[Writable]] attributes are set to the value of the corresponding field in _Desc_ if _Desc_ has that field, or to the attribute's <emu-xref href=\"#table-object-property-attributes\">default value</emu-xref> otherwise.": "{ let dp2 = (record [PropertyDescriptor] { \"Configurable\" : configurable, \"Enumerable\" : enumerable }) if (= Desc.Value absent) dp2.Value = undefined else dp2.Value = Desc.Value if (= Desc.Writable absent) dp2.Writable = false else dp2.Writable = Desc.Writable O.__MAP__[P] = dp2 }",
    "Replace the property named _P_ of object _O_ with an accessor property whose [[Configurable]] and [[Enumerable]] attributes are set to _configurable_ and _enumerable_, respectively, and whose [[Get]] and [[Set]] attributes are set to the value of the corresponding field in _Desc_ if _Desc_ has that field, or to the attribute's <emu-xref href=\"#table-object-property-attributes\">default value</emu-xref> otherwise.": "{ let ap2 = (record [PropertyDescriptor] { \"Configurable\" : configurable, \"Enumerable\" : enumerable }) if (=Desc.Get absent) ap2.Get = undefined else ap2.Get = Desc.Get if (= Desc.Set absent) ap2.Set = undefined else ap2.Set = Desc.Set O.__MAP__[P] = ap2 }",
    "Resume the context that is now on the top of the execution context stack as the running execution context.": "nop",
    "Return an Iterator object (<emu-xref href=\"#sec-iterator-interface\"></emu-xref>) whose `next` method iterates over all the String-valued keys of enumerable properties of _O_. The iterator object is never directly accessible to ECMAScript code. The mechanics and order of enumerating the properties is not specified but must conform to the rules specified below.": "{ call %0 = clo<\"CreateForInIterator\">(O) return %0 }",
    "Return the Number value for the integer represented by the 32-bit two's complement bit string _result_.": "return ([number] result)",
    "Return the result of applying bitwise complement to _oldValue_. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.": "return (~ oldValue)",
    "Return the result of left shifting _lnum_ by _shiftCount_ bits. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.": "return ([number] (<< ([math] lnum) shiftCount))",
    "Return the result of performing a sign-extending right shift of _lnum_ by _shiftCount_ bits. The most significant bit is propagated. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.": "return ([number] (>> ([math] lnum) shiftCount))",
    "Return the result of performing a zero-filling right shift of _lnum_ by _shiftCount_ bits. Vacated bits are filled with zero. The mathematical value of the result is exactly representable as a 32-bit unsigned bit string.": "return ([number] (>>> ([math] lnum) shiftCount))",
    "Return the value currently bound to _N_ in _envRec_.": "return envRec.__MAP__[N].BoundValue",
    "Set _P_'s essential internal methods, except for [[Call]] and [[Construct]], to the definitions specified in <emu-xref href=\"#sec-proxy-object-internal-methods-and-internal-slots\"></emu-xref>.": "{ P.GetPrototypeOf = clo<\"Record[ProxyExoticObject].GetPrototypeOf\"> P.SetPrototypeOf = clo<\"Record[ProxyExoticObject].SetPrototypeOf\"> P.IsExtensible = clo<\"Record[ProxyExoticObject].IsExtensible\"> P.PreventExtensions = clo<\"Record[ProxyExoticObject].PreventExtensions\"> P.GetOwnProperty = clo<\"Record[ProxyExoticObject].GetOwnProperty\"> P.DefineOwnProperty = clo<\"Record[ProxyExoticObject].DefineOwnProperty\"> P.HasProperty = clo<\"Record[ProxyExoticObject].HasProperty\"> P.Get = clo<\"Record[ProxyExoticObject].Get\"> P.Set = clo<\"Record[ProxyExoticObject].Set\"> P.Delete = clo<\"Record[ProxyExoticObject].Delete\"> P.OwnPropertyKeys = clo<\"Record[ProxyExoticObject].OwnPropertyKeys\"> }",
    "Set _obj_'s essential internal methods to the default ordinary object definitions specified in <emu-xref href=\"#sec-ordinary-object-internal-methods-and-internal-slots\"></emu-xref>.": "nop",
    "Set the bound value for _N_ in _envRec_ to _V_.": "envRec.__MAP__[N].BoundValue = V",
    "_op_ is `|`. Let _result_ be the result of applying the bitwise inclusive OR operation to _lbits_ and _rbits_.": "let result = (| lbits rbits)"
  }
}
